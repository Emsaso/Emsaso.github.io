<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="utf-8" />
    <title></title>
</head>

<body>

    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script src="testdata.js"></script>
    <script>
        let parser = new DOMParser();
        let xmlDoc = parser.parseFromString(gpx, "text/xml");
        let trekStart = xmlDoc.getElementsByTagName('time');
        let trekPoints = xmlDoc.getElementsByTagName('trkpt');
        let initTime = Array.from(trekPoints[0].children).filter(p => p.tagName == 'time')[0].textContent;
        let initTime2 = Array.from(trekPoints[1].children).filter(p => p.tagName == 'time')[0].textContent;
        let text = "";
        let finalValueInKm = 0;
        let hypotenuse = 0;
        let i = 0;
        let y = 0;
        let estTimeSec = 0;
        let estTimeSec2 = 0;
        let totSeconds = 0;
        let totMinutes = 0;
        let totHours = 0;
        let latitudeEnd = 0;
        let longitudeEnd = 0;
        let result = document.createElement("div");
        result.innerHTML = `${latitudeEnd} ${longitudeEnd}`
        document.body.appendChild(result);

        run();
        function run() {
            getLatLon(i);
            getLatLonEveryCheckpoint();
            getLatLonEverySecond();
        }

        function getLatLonEveryCheckpoint() {
            let timer = setInterval(() => {
                let coordinates = getLatLon(i);
                let latitude = coordinates[0];
                let longitude = coordinates[1];
                i++;
                totSeconds++;
                calculateTime();
                if (!isNaN(latitude) || !isNaN(longitude)) {
                    console.log(z, latitude, longitude);
                }
                if (i >= trekPoints.length - 4) {
                    clearInterval(timer);
                } else {
                    clearInterval(timer);
                    getLatLonEverySecond();
                    getLatLonEveryCheckpoint();
                    latitudeEnd = latitude;
                    longitudeEnd = longitude;
                    result.innerHTML = `${latitudeEnd} ${longitudeEnd}`
                }
            }, estTimeSec2 * 1000);
        }

        function getLatLonEverySecond() {
            if (i + 1 >= 1 && i + y <= trekPoints.length) {
                let timer2 = setInterval(() => {
                    coordinates2 = getLatLon(i + 1);
                    latitude2 = coordinates2[0];
                    longitude2 = coordinates2[1];
                    coordinates1 = getLatLon(i);
                    latitude1 = coordinates1[0];
                    longitude1 = coordinates1[1];
                    y++;
                    totSeconds++;
                    calculateTime();
                    let latitude = latitude1 + ((latitude2 - latitude1) / estTimeSec * y);
                    let longitude = longitude1 + ((longitude2 - longitude1) / estTimeSec * y);
                    console.log("\t" + z, latitude, longitude);
                    latitudeEnd = latitude;
                    longitudeEnd = longitude;
                    result.innerHTML = `${latitudeEnd} ${longitudeEnd}`
                    if (y >= Math.floor(estTimeSec) - 1) {
                        clearInterval(timer2);
                        y = 0;
                    }
                }, 1000);
            }
        }

        function getLatLon(i) {
            let initTimeModified = initTime.slice(0, -10);
            let initTimeModified2 = initTime2.slice(0, -10);
            initTimeModified = initTimeModified.split("-");
            initTimeModified2 = initTimeModified2.split("-");
            let secondsSinceStart = initTimeModified[1] + "/" + initTimeModified[2] + "/" + initTimeModified[0];
            let secondsSinceStart2 = initTimeModified2[1] + "/" + initTimeModified2[2] + "/" + initTimeModified2[0];
            let correctTime = (parseInt(new Date(secondsSinceStart).getTime()) + i - parseInt(new Date(
                secondsSinceStart).getTime()));
            let correctTime2 = (parseInt(new Date(secondsSinceStart2).getTime()) + (i + 1) - parseInt(new Date(
                secondsSinceStart2).getTime()));
            // console.log(parseInt(correctTime));
            let trekPoint1 = trekPoints[parseInt(correctTime)];
            let trekPoint2 = trekPoints[parseInt(correctTime + 1)];
            let trekPoint12 = trekPoints[parseInt(correctTime2)];
            let trekPoint22 = trekPoints[parseInt(correctTime2 + 1)];
            let lat1 = trekPoint1.getAttribute('lat');
            let lat2 = trekPoint2.getAttribute('lat');
            let lon1 = trekPoint1.getAttribute('lon');
            let lon2 = trekPoint2.getAttribute('lon');
            let children1 = Array.from(trekPoint1.children);
            let children2 = Array.from(trekPoint2.children);
            let children12 = Array.from(trekPoint12.children);
            let children22 = Array.from(trekPoint22.children);
            let ele1 = children1.filter(p => p.tagName == 'ele')[0].textContent;
            let ele2 = children2.filter(p => p.tagName == 'ele')[0].textContent;
            finalValueInKm += calculateDistance(lat1, lon1, ele1, lat2, lon2, ele2);
            let intervalValue = calculateDistance(lat1, lon1, ele1, lat2, lon2, ele2);
            let time1 = Date.parse(children1.filter(p => p.tagName == 'time')[0].textContent);
            let time2 = Date.parse(children2.filter(p => p.tagName == 'time')[0].textContent);
            let time12 = Date.parse(children12.filter(p => p.tagName == 'time')[0].textContent);
            let time22 = Date.parse(children22.filter(p => p.tagName == 'time')[0].textContent);
            let timeInHours = (time2 - time1) / 3600000;
            let timeInMinutes = (time2 - time1) / 60000;
            let timeInSeconds = (time2 - time1) / 1000;
            let timeInSeconds2 = (time22 - time12) / 1000;
            let kmH = (intervalValue / timeInHours).toFixed(2);
            let latPrSec = (lat2 - lat1) / timeInSeconds;
            let lonPrSec = (lon2 - lon1) / timeInSeconds;
            let tiredness = calculateTiredness(correctTime);
            let experience = calculateProwess("pro");
            let weather = calculateRain("clearWeather");
            let steepness = calculateSteepness(ele1, ele2);
            let speedVariables = tiredness / experience / weather * steepness;

            let estimatedTimeInSeconds = timeInSeconds * speedVariables;
            estTimeSec = estimatedTimeInSeconds;

            let estimatedTimeInSeconds2 = timeInSeconds2 * speedVariables;
            estTimeSec2 = estimatedTimeInSeconds2;

            let estimatedKmH = (kmH / speedVariables).toFixed(2);
            let estimatedLatitude = latPrSec / speedVariables;
            let estimatedLongitude = lonPrSec / speedVariables;
            let finalLatitude = lat1 - estimatedLatitude;
            let finalLongitute = lon1 - estimatedLongitude;
            // text +=
            //     `<tr><th>${parseFloat(lat1).toFixed(7)}</th><th>${parseFloat(lon1).toFixed(7)}</th><th>${ele1}</th><th>${timeInSeconds.toFixed(2)}</th>` +
            //     `<th>${kmH}</th><th>${parseFloat(latPrSec).toFixed(7)}</th><th>${parseFloat(lonPrSec).toFixed(7)}</th><th>${estimatedTimeInSeconds.toFixed(2)}</th>` +
            //     `<th>${estimatedKmH}</th><th>${estimatedLatitude.toFixed(7)}</th><th>${estimatedLongitude.toFixed(7)}</th></tr>`;
            //         let latAndLon = estimatedLatitude.toFixed(7) + " " + estimatedLongitude.toFixed(7);
            return [finalLatitude, finalLongitute];
            // return [estimatedLatitude, estimatedLongitude];
        }

        function calculateTime() {
            if (totSeconds >= 60) {
                totMinutes++;
                totSeconds = 0;
            }
            if (totMinutes >= 60) {
                totHours++;
                totMinutes = 0;
            }
            z = ("0" + totHours).slice(-2) + ":" + ("0" + totMinutes).slice(-2) + ":" + ("0" +
                totSeconds).slice(-2);
        }

        function calculateDistance(lat1, lon1, ele1, lat2, lon2, ele2) {
            if ((lat1 == lat2) && (lon1 == lon2) && (ele1 == ele2)) {
                return 0;
            } else {
                let radlat1 = Math.PI * lat1 / 180;
                let radlat2 = Math.PI * lat2 / 180;
                let theta = lon1 - lon2;
                let radtheta = Math.PI * theta / 180;
                let dist = Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(
                    radtheta);
                if (dist > 1) {
                    dist = 1;
                }
                dist = Math.acos(dist);
                dist = dist * 180 / Math.PI;
                dist = dist * 60 * 1.1515;
                dist *= 1.609344;
                dist *= 1000;
                var height;
                if (ele1 > ele2) {
                    height = (ele1) - (ele2);
                } else {
                    height = (ele2) - (ele1);
                }
                if (height == 0) {
                    dist = dist;
                } else {
                    hypotenuse = Math.sqrt((dist * dist) + (height * height));
                }
                dist /= 1000;
                return dist;
            }
        }

        function calculateTiredness(i) {
            let value = 10;
            let tiredness = (((i / trekPoints.length) / (i / trekPoints.length + value)) + 1);
            return tiredness
        }

        function calculateProwess(experience) {
            let prowess;
            switch (experience) {
                case "beginner":
                    prowess = 0.85
                    break;
                case "novice":
                    prowess = 0.88
                    break;
                case "good":
                    prowess = 0.91
                    break;
                case "advanced":
                    prowess = 0.94
                    break;
                case "experienced":
                    prowess = 0.97
                    break;
                case "pro":
                    prowess = 1
                    break;
                default:
                    prowess = 1;
            }
            return prowess
        }

        function calculateRain(rainGauge) {
            let weather;
            switch (rainGauge) {
                case "downpour":
                    weather = 0.85;
                    break;
                case "rain":
                    weather = 0.90;
                    break;
                case "sprinkling":
                    weather = 0.95;
                    break;
                case "clearWeather":
                    weather = 1;
                    break;
                default:
                    weather = 1;
            }
            return weather
        }

        function calculateSteepness(ele1, ele2) {
            let steepness = ((ele2 - ele1) / ele2) + 1;
            return steepness
        }
        // let distanceDiv = document.createElement("div");
        // distanceDiv.innerHTML = `Total kilometers: ${finalValueInKm.toFixed(3)} km, Total rows: ${trekPoints.length}`;
        // distanceDiv.style.textAlign = "center";
        // distanceDiv.style.fontWeight = "bold";
        // document.body.appendChild(distanceDiv);

        // let colorCodeDiv = document.createElement("div");
        // colorCodeDiv.innerHTML =
        //     "<span style='color: red;'>Red</span> is initial values. <span style='color: green;'>Green</span> is optimal values per second. <span style='color: blue;'>Blue</span> is expected values per second."
        // colorCodeDiv.style.textAlign = "center";
        // colorCodeDiv.style.fontWeight = "bold";
        // document.body.appendChild(colorCodeDiv)

        // let keywordExplanationDiv = document.createElement("div");
        // keywordExplanationDiv.innerHTML =
        //     "S/Cp is 'Seconds per Checkpoint'. Km/H is 'Kilometers per Hour'. Latitude or Longitude/S is 'Longitude/Latitude per second'"
        // keywordExplanationDiv.style.textAlign = "center";
        // keywordExplanationDiv.style.fontWeight = "bold";
        // document.body.appendChild(keywordExplanationDiv);

        // let table = document.createElement("table");
        // let tableHeaders =
        //     "<tr><th>Latitude</th><th>Longitude</th><th>Elevation</th><th>S/Cp</th><th>Km/H</th><th>Latitude/S</th><th>Longitude/S</th><th>S/Cp</th><th>Km/H</th><th>Latitude/S</th><th>Longitude/S</th><tr/>";
        // let emptyHeader = "<tr><th>‎</th></tr>";
        // table.innerHTML = tableHeaders + emptyHeader + text;
        // table.style.border = "1px solid black";
        // table.style.width = "90vw";
        // table.style.margin = "auto";
        // document.body.appendChild(table);
        // for (let i = 0; i < 11; i++) {
        //     var th = document.getElementsByTagName("th")[i];
        //     if (i < 3) {
        //         th.style.color = "red";
        //     } else if (i < 7) {
        //         th.style.color = "green";
        //     } else if (i < 11) {
        //         th.style.color = "blue";
        //     } else {
        //         th.style.color = "black";
        //     }
        // }
    </script>
</body>

</html>